diff --git a/drivers/phy/Kconfig b/drivers/phy/Kconfig
index 7dc726d..17bc054 100644
--- a/drivers/phy/Kconfig
+++ b/drivers/phy/Kconfig
@@ -481,6 +481,7 @@ config PHY_CYGNUS_PCIE
 	  If unsure, say N.
 
 source "drivers/phy/tegra/Kconfig"
+source "drivers/phy/hibvt/Kconfig"
 
 config PHY_NS2_PCIE
 	tristate "Broadcom Northstar2 PCIe PHY driver"
diff --git a/drivers/phy/Makefile b/drivers/phy/Makefile
index a534cf5..b69cc4b 100644
--- a/drivers/phy/Makefile
+++ b/drivers/phy/Makefile
@@ -59,4 +59,5 @@ obj-$(CONFIG_PHY_BRCM_SATA)		+= phy-brcm-sata.o
 obj-$(CONFIG_PHY_PISTACHIO_USB)		+= phy-pistachio-usb.o
 obj-$(CONFIG_PHY_CYGNUS_PCIE)		+= phy-bcm-cygnus-pcie.o
 obj-$(CONFIG_ARCH_TEGRA) += tegra/
+obj-$(CONFIG_ARCH_HISI_BVT) += hibvt/
 obj-$(CONFIG_PHY_NS2_PCIE)		+= phy-bcm-ns2-pcie.o
diff --git a/drivers/phy/hibvt/Kconfig b/drivers/phy/hibvt/Kconfig
new file mode 100644
index 0000000..d9f72be
--- /dev/null
+++ b/drivers/phy/hibvt/Kconfig
@@ -0,0 +1,26 @@
+config PHY_HISI_SATA
+	tristate "Hisilicon sata nano phy support"
+	depends on (ARCH_HI3536DV100 && OF && HAS_IOMEM)
+	default y if ARCH_HI3536DV100
+	select GENERIC_PHY
+	help
+	  Enable this to support the sata phy that is part of
+	  sata driver for hisilicon
+
+config HISI_SATA_MODE
+	int "Hisi sata interworking speed mode(1.5G:0/3G:1/6G:2)"
+	depends on PHY_HISI_SATA
+	range 0 1 if ARCH_HI3536DV100
+	default "1" if ARCH_HI3536DV100
+	help
+	  Hisilicon sata interworking speed mode
+
+config PHY_HISI_USB2
+	tristate "HISI USB2 PHY Driver"
+	default y
+	select GENERIC_PHY
+	help
+	Support for PHY on Hisilicon Socs. This Phy supports
+	USB 1.5Mb/s, USB 12Mb/s, USB 480Mb/s speeds. It suppots one
+	USB host port to accept one USB device. Support init the phy
+	and adjust phy Eye Diagram.
diff --git a/drivers/phy/hibvt/Makefile b/drivers/phy/hibvt/Makefile
new file mode 100644
index 0000000..63ff999
--- /dev/null
+++ b/drivers/phy/hibvt/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_PHY_HISI_SATA)			+= phy-hisi-sata.o
+obj-$(CONFIG_PHY_HISI_USB2)			+= phy-hisi-usb.o
+obj-$(CONFIG_ARCH_HI3536DV100)		+= phy-hi3536d-usb.o
diff --git a/drivers/phy/hibvt/phy-hi3536d-usb.c b/drivers/phy/hibvt/phy-hi3536d-usb.c
new file mode 100644
index 0000000..ffd1b58
--- /dev/null
+++ b/drivers/phy/hibvt/phy-hi3536d-usb.c
@@ -0,0 +1,210 @@
+#include <linux/delay.h>
+#include <linux/phy/phy.h>
+#include <linux/of_address.h>
+#include "phy-hisi-usb.h"
+
+#define USB2_CTRL		0xb8
+#define USB2_BUS_CKEN		(1 << 0)
+#define USB2_OHCI48M_CKEN	(1 << 1)
+#define USB2_OHCI12M_CKEN	(1 << 2)
+#define USB2_HST_PHY_CKEN	(1 << 4)
+#define USB2_UTMI0_CKEN		(1 << 5)
+#define USB2_UTMI1_CKEN		(1 << 6)
+#define USB2_BUS_SRST_REQ	(1 << 12)
+#define USB2_UTMI0_SRST_REQ	(1 << 13)
+#define USB2_UTMI1_SRST_REQ	(1 << 14)
+#define USB2_HST_PHY_SYST_REQ	(1 << 16)
+
+#define REG_USB2_PHY0		0xbc
+#define USB_PHY0_REF_CKEN	(1 << 0)
+#define USB_PHY0_SRST_REQ	(1 << 1)
+#define USB_PHY0_SRST_TREQ	(1 << 2)
+#define USB_PHY1_SRST_TREQ	(1 << 3)
+#define USB_PHY0_TEST_SRST_REQ	(1 << 4)
+
+#define MISC_CTRL_TRIM		0x50
+#define USB_R_TUNING_1		0x800c
+#define USB_R_TUNING_2		0x840c
+#define MISC_CTRL20_23		(1 << 23)
+#define MISC_CTRL20_24		(1 << 24)
+#define MISC_CTRL20_25		(1 << 25)
+#define MISC_CTRL20_26		(1 << 26)
+#define MISC_CTRL20_27		(1 << 27)
+#define TRIM_CONFIG_2		(1 << 2)
+#define TRIM_CONFIG_3		(1 << 3)
+#define TRIM_CONFIG_4		(1 << 4)
+#define TRIM_CONFIG_5		(1 << 5)
+#define TRIM_CONFIG_6		(1 << 6)
+
+#define MISC_CTRL			(1 << 22)
+#define REG_USB2_CFG		0x8018
+#define USB2_CFG_VAL		0x05
+#define USB2_PHY0_CTLL		0x54
+
+/* param config */
+#define EYE_HEIGHT_CFG		0x8008
+#define EYE_HEIGHT_RECFG	0x8408
+#define EYE_HEIGHT_VAL		0x5c
+
+#define PRE_OPEN_CFG		0x8000
+#define PRE_OPEN_RECFG		0x8400
+#define PRE_OPEN_VAL		0x1c
+
+#define PRE_IMP_CFG			0x8014
+#define PRE_IMP_RECFG		0x8414
+#define PRE_IMP_VAL			0x80
+
+#define DISC_CFG			0x8010
+#define DISC_RECFG			0x8410
+#define DISC_CFG_VAL		0x17
+
+
+void hisi_usb_phy_on(struct phy *phy)
+{
+	int reg, trim_reg;
+	struct hisi_priv *priv = phy_get_drvdata(phy);
+
+	/* misc ctrl */
+	reg = readl(priv->misc_ctrl + USB2_PHY0_CTLL);
+	reg |= MISC_CTRL;
+	writel_relaxed(reg, priv->misc_ctrl + USB2_PHY0_CTLL);
+	udelay(200);
+
+	/* reset enable */
+	reg = readl(priv->peri_ctrl + USB2_CTRL);
+	reg |= (USB2_BUS_SRST_REQ
+		| USB2_UTMI0_SRST_REQ
+		| USB2_HST_PHY_SYST_REQ
+		| USB2_UTMI1_SRST_REQ);
+	writel(reg, priv->peri_ctrl + USB2_CTRL);
+	udelay(200);
+
+	reg = readl(priv->peri_ctrl + REG_USB2_PHY0);
+	reg |= (USB_PHY0_SRST_REQ
+		| USB_PHY0_SRST_TREQ
+		| USB_PHY1_SRST_TREQ);
+	writel(reg, priv->peri_ctrl + REG_USB2_PHY0);
+	udelay(200);
+
+	/* open ref clock */
+	reg = readl(priv->peri_ctrl + REG_USB2_PHY0);
+	reg |= (USB_PHY0_REF_CKEN);
+	writel(reg, priv->peri_ctrl + REG_USB2_PHY0);
+	udelay(100);
+
+	/* cancel power on reset */
+	reg = readl(priv->peri_ctrl + REG_USB2_PHY0);
+	reg &= ~(USB_PHY0_SRST_REQ);
+	reg &= ~(USB_PHY0_TEST_SRST_REQ);
+	writel(reg, priv->peri_ctrl + REG_USB2_PHY0);
+	udelay(300);
+
+	writel(USB2_CFG_VAL, priv->misc_ctrl + REG_USB2_CFG);
+	udelay(200);
+
+	/* cancel port reset */
+	reg = readl(priv->peri_ctrl + REG_USB2_PHY0);
+	reg &= ~(USB_PHY0_SRST_TREQ);
+	reg &= ~(USB_PHY1_SRST_TREQ);
+	writel(reg, priv->peri_ctrl + REG_USB2_PHY0);
+	udelay(300);
+
+	/* cancel control reset */
+	reg = readl(priv->peri_ctrl + USB2_CTRL);
+	reg &= ~(USB2_BUS_SRST_REQ
+		| USB2_UTMI0_SRST_REQ
+		| USB2_HST_PHY_SYST_REQ
+		| USB2_UTMI1_SRST_REQ);
+	reg |= (USB2_BUS_CKEN
+		| USB2_OHCI48M_CKEN
+		| USB2_OHCI12M_CKEN
+		| USB2_HST_PHY_CKEN
+		| USB2_UTMI0_CKEN
+		| USB2_UTMI1_CKEN);
+	writel(reg, priv->peri_ctrl + USB2_CTRL);
+	udelay(200);
+
+	/* Trim config */
+	reg = readl(priv->misc_ctrl + MISC_CTRL_TRIM);
+	reg &= (MISC_CTRL20_23
+			| MISC_CTRL20_24
+			| MISC_CTRL20_25
+			| MISC_CTRL20_26
+			| MISC_CTRL20_27);
+	reg = reg >> 21;
+	if(reg){
+		trim_reg = readl(priv->misc_ctrl + USB_R_TUNING_1);
+		trim_reg &= ~(TRIM_CONFIG_2
+				| TRIM_CONFIG_3
+				| TRIM_CONFIG_4
+				| TRIM_CONFIG_5
+				| TRIM_CONFIG_6);
+		trim_reg |= reg;
+		writel(trim_reg, priv->misc_ctrl + USB_R_TUNING_1);
+
+		trim_reg = readl(priv->misc_ctrl + USB_R_TUNING_2);
+		trim_reg &= ~(TRIM_CONFIG_2
+				| TRIM_CONFIG_3
+				| TRIM_CONFIG_4
+				| TRIM_CONFIG_5
+				| TRIM_CONFIG_6);
+		trim_reg |= reg;
+		writel(trim_reg, priv->misc_ctrl + USB_R_TUNING_2);
+	}
+
+	/* eye height config */
+	writel_relaxed(EYE_HEIGHT_VAL, priv->misc_ctrl + EYE_HEIGHT_CFG);
+	udelay(100);
+	writel_relaxed(EYE_HEIGHT_VAL, priv->misc_ctrl + EYE_HEIGHT_RECFG);
+	udelay(100);
+
+	/* pre open */
+	writel_relaxed(PRE_OPEN_VAL, priv->misc_ctrl + PRE_OPEN_CFG);
+	udelay(100);
+	writel_relaxed(PRE_OPEN_VAL, priv->misc_ctrl + PRE_OPEN_RECFG);
+	udelay(100);
+
+	/* pre improve */
+	writel_relaxed(PRE_IMP_VAL, priv->misc_ctrl + PRE_IMP_CFG);
+	udelay(100);
+	writel_relaxed(PRE_IMP_VAL, priv->misc_ctrl + PRE_IMP_RECFG);
+	udelay(100);
+
+	/* disconnects */
+	writel_relaxed(DISC_CFG_VAL, priv->misc_ctrl + DISC_CFG);
+	udelay(100);
+	writel_relaxed(DISC_CFG_VAL, priv->misc_ctrl + DISC_RECFG);
+	udelay(100);
+}
+EXPORT_SYMBOL(hisi_usb_phy_on);
+
+void hisi_usb_phy_off(struct phy *phy)
+{
+	int reg;
+	struct hisi_priv *priv = phy_get_drvdata(phy);
+
+	reg = readl(priv->peri_ctrl + REG_USB2_PHY0);
+	reg |= (USB_PHY0_SRST_REQ
+		| USB_PHY0_SRST_TREQ
+		| USB_PHY1_SRST_TREQ);
+	writel(reg, priv->peri_ctrl + REG_USB2_PHY0);
+	udelay(100);
+
+	/* close clock */
+	reg = readl(priv->peri_ctrl + REG_USB2_PHY0);
+	reg &= ~USB_PHY0_REF_CKEN;
+	writel(reg, priv->peri_ctrl + REG_USB2_PHY0);
+	udelay(300);
+
+	/* close clock */
+	reg = readl(priv->peri_ctrl + USB2_CTRL);
+	reg &= ~(USB2_BUS_CKEN
+		| USB2_OHCI48M_CKEN
+		| USB2_OHCI12M_CKEN
+		| USB2_HST_PHY_CKEN
+		| USB2_UTMI0_CKEN
+		| USB2_UTMI1_CKEN);
+	writel(reg, priv->peri_ctrl + USB2_CTRL);
+	udelay(200);
+}
+EXPORT_SYMBOL(hisi_usb_phy_off);
diff --git a/drivers/phy/hibvt/phy-hi3536dv100-sata.c b/drivers/phy/hibvt/phy-hi3536dv100-sata.c
new file mode 100644
index 0000000..91b8f0a
--- /dev/null
+++ b/drivers/phy/hibvt/phy-hi3536dv100-sata.c
@@ -0,0 +1,208 @@
+/*
+ * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/io.h>
+#include <mach/io.h>
+#include <mach/platform.h>
+
+#include "phy-hisi-sata.h"
+
+enum {
+	HISI_SATA_PERI_CTRL		= IO_ADDRESS(REG_CRG_BASE),
+	HISI_SATA_PERI_CRG44	= (HISI_SATA_PERI_CTRL + 0xB0),
+	HISI_SATA_PERI_CRG45	= (HISI_SATA_PERI_CTRL + 0xB4),
+	HISI_SATAPHY_MISC_CTRL	= IO_ADDRESS(REG_MISC_CTRL_BASE),
+	HISI_SATAPHY_MISC_CTRL22 = (HISI_SATAPHY_MISC_CTRL + 0x58),
+
+	HISI_SATA_PHY0_CLK_EN	= (1 << 0),
+	HISI_SATA_PHY0_RST		= (1 << 1),
+	HISI_SATA_PHY0_REFCLK_SEL_MASK = (0x3 << 2),
+	HISI_SATA_PHY0_REFCLK_SEL = (0x2 << 2),
+
+	HISI_SATA_BUS_CKEN		= (1 << 0),
+	HISI_SATA_RX0_CKEN		= (1 << 1),
+	HISI_SATA_CKO_ALIVE_CKEN	= (1 << 2),
+	HISI_SATA_TX0_CKEN		= (1 << 3),
+	HISI_SATA_BUS_SRST_REQ	= (1 << 8),
+	HISI_SATA_CKO_ALIVE_SRST_REQ	= (1 << 9),
+	HISI_SATA_RX0_SRST_REQ	= (1 << 10),
+	HISI_SATA0_SRST_REQ		= (1 << 11),
+
+	FIFOTH_VALUE    = 0xFEED9F24,
+	PHY_CONFIG_1_5G = 0x0e180000,
+	PHY_CONFIG_3G   = 0x0e390000,
+
+	PHY_SG_1_5G = 0x50438,
+	PHY_SG_3G   = 0x50438,
+};
+
+static void hisi_sata_poweron(void)
+{
+}
+
+static void hisi_sata_poweroff(void)
+{
+}
+
+void hisi_sata_reset_rxtx_assert(void)
+{
+	unsigned int tmp_val;
+
+	tmp_val = readl((void *)HISI_SATA_PERI_CRG45);
+
+	tmp_val |= HISI_SATA_RX0_SRST_REQ | HISI_SATA0_SRST_REQ;
+	writel(tmp_val, (void *)HISI_SATA_PERI_CRG45);
+}
+EXPORT_SYMBOL(hisi_sata_reset_rxtx_assert);
+
+void hisi_sata_reset_rxtx_deassert(void)
+{
+	unsigned int tmp_val;
+
+	tmp_val = readl((void *)HISI_SATA_PERI_CRG45);
+
+	tmp_val &= ~(HISI_SATA_RX0_SRST_REQ | HISI_SATA0_SRST_REQ);
+
+	writel(tmp_val, (void *)HISI_SATA_PERI_CRG45);
+}
+EXPORT_SYMBOL(hisi_sata_reset_rxtx_deassert);
+
+static void hisi_sata_reset(void)
+{
+	unsigned int tmp_val;
+
+	tmp_val = readl((void *)HISI_SATA_PERI_CRG45);
+
+	tmp_val |= HISI_SATA_BUS_SRST_REQ | HISI_SATA_CKO_ALIVE_SRST_REQ
+		| HISI_SATA_RX0_SRST_REQ | HISI_SATA0_SRST_REQ;
+	writel(tmp_val, (void *)HISI_SATA_PERI_CRG45);
+}
+
+static void hisi_sata_unreset(void)
+{
+	unsigned int tmp_val;
+
+	tmp_val = readl((void *)HISI_SATA_PERI_CRG45);
+
+	tmp_val &= ~(HISI_SATA_BUS_SRST_REQ | HISI_SATA_CKO_ALIVE_SRST_REQ
+		| HISI_SATA_RX0_SRST_REQ | HISI_SATA0_SRST_REQ);
+
+	writel(tmp_val, (void *)HISI_SATA_PERI_CRG45);
+}
+
+static void hisi_sata_phy_reset(void)
+{
+	unsigned int tmp_val;
+
+	tmp_val = readl((void *)HISI_SATA_PERI_CRG44);
+	tmp_val |= HISI_SATA_PHY0_RST;
+	writel(tmp_val, (void *)HISI_SATA_PERI_CRG44);
+}
+
+static void hisi_sata_phy_unreset(void)
+{
+	unsigned int tmp_val;
+
+	tmp_val = readl((void *)HISI_SATA_PERI_CRG44);
+	tmp_val &= ~HISI_SATA_PHY0_RST;
+	writel(tmp_val, (void *)HISI_SATA_PERI_CRG44);
+}
+
+static void hisi_sata_clk_enable(void)
+{
+	unsigned int tmp_val, tmp_reg;
+
+	tmp_val = readl((void *)HISI_SATA_PERI_CRG44);
+	tmp_reg = readl((void *)HISI_SATA_PERI_CRG45);
+	tmp_val |= HISI_SATA_PHY0_CLK_EN;
+	tmp_reg |= HISI_SATA_RX0_CKEN | HISI_SATA_TX0_CKEN;
+	writel(tmp_val, (void *)HISI_SATA_PERI_CRG44);
+	writel(tmp_reg, (void *)HISI_SATA_PERI_CRG45);
+
+}
+
+static void hisi_sata_clk_disable(void)
+{
+}
+
+static void hisi_sata_clk_reset(void)
+{
+}
+
+static void hisi_sata_phy_clk_sel(void)
+{
+	unsigned int tmp_val;
+
+	tmp_val = readl((void *)HISI_SATA_PERI_CRG44);
+	tmp_val &= ~HISI_SATA_PHY0_REFCLK_SEL_MASK;
+	tmp_val |= HISI_SATA_PHY0_REFCLK_SEL;
+	writel(tmp_val, (void *)HISI_SATA_PERI_CRG44);
+}
+
+void hisi_sata_set_fifoth(void *mmio)
+{
+	writel(FIFOTH_VALUE, (mmio + 0x100 + PORT_FIFOTH));
+}
+EXPORT_SYMBOL(hisi_sata_set_fifoth);
+
+static void hisi_sata_phy_config(void *mmio, int phy_mode)
+{
+	unsigned int tmp_val, phy_config = PHY_CONFIG_3G;
+	unsigned int phy_sg = PHY_SG_3G;
+
+	hisi_sata_set_fifoth(mmio);
+
+	tmp_val = readl(mmio + PHY_CTL1);
+	tmp_val |= PHY_DATA_INVERT;
+	writel(tmp_val, (mmio + PHY_CTL1));
+	tmp_val = readl(mmio + PHY_CTL2);
+	tmp_val |= PHY_DATA_INVERT;
+	writel(tmp_val, (mmio + PHY_CTL2));
+
+	tmp_val = readl(mmio + PHY_RST_BACK_MASK);
+	tmp_val |= PHY_RST_MASK_ALL;
+	tmp_val &= ~PHY0_RST_MASK;
+	writel(tmp_val, (mmio + PHY_RST_BACK_MASK));
+
+	if (phy_mode == PHY_MODE_1_5G) {
+		phy_config = PHY_CONFIG_1_5G;
+		phy_sg = PHY_SG_1_5G;
+	}
+
+	if (phy_mode == PHY_MODE_3G) {
+		phy_config = PHY_CONFIG_3G;
+		phy_sg = PHY_SG_3G;
+	}
+
+	writel(phy_config, (mmio + 0x100 + PORT_PHYCTL));
+	writel(phy_sg, (mmio + 0x100 + PORT_PHYCTL1));
+
+	/* force pll always work at 6Gbps, force cdr at 3Gbps
+	 * for gen1 and at 6Gbps for gen2
+	 */
+	writel(0x70f, (void *)HISI_SATAPHY_MISC_CTRL22);
+	writel(0x74f, (void *)HISI_SATAPHY_MISC_CTRL22);
+	writel(0x70f, (void *)HISI_SATAPHY_MISC_CTRL22);
+	writel(0x0, (void *)HISI_SATAPHY_MISC_CTRL22);
+
+	/* disable SSC*/
+	writel(0x802, (void *)HISI_SATAPHY_MISC_CTRL22);
+	writel(0x842, (void *)HISI_SATAPHY_MISC_CTRL22);
+	writel(0x802, (void *)HISI_SATAPHY_MISC_CTRL22);
+	writel(0x0, (void *)HISI_SATAPHY_MISC_CTRL22);
+}
diff --git a/drivers/phy/hibvt/phy-hisi-sata.c b/drivers/phy/hibvt/phy-hisi-sata.c
new file mode 100644
index 0000000..2d6cbf5
--- /dev/null
+++ b/drivers/phy/hibvt/phy-hisi-sata.c
@@ -0,0 +1,151 @@
+/*
+ * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <mach/io.h>
+
+static unsigned int phy_mode = CONFIG_HISI_SATA_MODE;
+
+#ifdef MODULE
+module_param(mode_3g, uint, 0600);
+MODULE_PARM_DESC(phy_mode, "sata phy mode (0:1.5G;1:3G(default);2:6G)");
+#endif
+
+#ifdef CONFIG_ARCH_HI3536DV100
+#include "phy-hi3536dv100-sata.c"
+#endif
+
+static int hisi_sata_phy_init(struct phy *phy)
+{
+	void __iomem *mmio = phy_get_drvdata(phy);
+
+	hisi_sata_poweron();
+	hisi_sata_reset();
+	hisi_sata_phy_reset();
+	hisi_sata_phy_clk_sel();
+	hisi_sata_clk_enable();
+	msleep(20);
+	hisi_sata_phy_unreset();
+	msleep(20);
+	hisi_sata_unreset();
+	msleep(20);
+	hisi_sata_phy_config(mmio, phy_mode);
+
+	return 0;
+}
+
+static int hisi_sata_phy_exit(struct phy *phy)
+{
+	hisi_sata_phy_reset();
+	msleep(20);
+	hisi_sata_reset();
+	msleep(20);
+	hisi_sata_clk_reset();
+	msleep(20);
+	hisi_sata_clk_disable();
+	hisi_sata_poweroff();
+	msleep(20);
+
+	return 0;
+}
+
+static struct phy_ops hisi_sata_phy_ops = {
+	.init		= hisi_sata_phy_init,
+	.exit		= hisi_sata_phy_exit,
+	.owner		= THIS_MODULE,
+};
+
+static int hisi_sata_phy_probe(struct platform_device *pdev)
+{
+	struct phy_provider *phy_provider;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct phy *phy;
+	void __iomem *mmio;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "failed to get reg base\n");
+		return -ENOENT;
+	}
+
+	mmio = devm_ioremap(dev, res->start, resource_size(res));
+	if (!mmio)
+		return -ENOMEM;
+
+	phy = devm_phy_create(dev, NULL, &hisi_sata_phy_ops);
+	if (IS_ERR(phy)) {
+		dev_err(dev, "failed to create PHY\n");
+		return PTR_ERR(phy);
+	}
+
+	phy_set_drvdata(phy, mmio);
+
+	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+	if (IS_ERR(phy_provider))
+		return PTR_ERR(phy_provider);
+
+	return 0;
+}
+
+static int hisi_sata_phy_suspend(struct platform_device *pdev,
+		pm_message_t state)
+{
+	struct device *dev = &pdev->dev;
+	struct phy *phy = to_phy(dev);
+
+	hisi_sata_phy_exit(phy);
+
+	return 0;
+}
+
+static int hisi_sata_phy_resume(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct phy *phy = to_phy(dev);
+
+	hisi_sata_phy_init(phy);
+
+	return 0;
+}
+
+static const struct of_device_id hisi_sata_phy_of_match[] = {
+	{.compatible = "hisilicon,hisi-sata-phy",},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, hisi_sata_phy_of_match);
+
+static struct platform_driver hisi_sata_phy_driver = {
+	.probe	= hisi_sata_phy_probe,
+	.suspend = hisi_sata_phy_suspend,
+	.resume  = hisi_sata_phy_resume,
+	.driver = {
+		.name	= "hisi-sata-phy",
+		.of_match_table	= hisi_sata_phy_of_match,
+	}
+};
+module_platform_driver(hisi_sata_phy_driver);
+
+MODULE_AUTHOR("HiSilicon BVT");
+MODULE_DESCRIPTION("HISILICON SATA PHY driver");
+MODULE_ALIAS("platform:hisi-sata-phy");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/phy/hibvt/phy-hisi-sata.h b/drivers/phy/hibvt/phy-hisi-sata.h
new file mode 100644
index 0000000..a767c68
--- /dev/null
+++ b/drivers/phy/hibvt/phy-hisi-sata.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+enum {
+	/* hisi extended global controller registers */
+	PHY_CTL0    = 0xA0,
+	PHY_CTL1    = 0xA4,
+	PHY_RST_BACK_MASK	= 0xAC,
+	PHY_CTL2	= 0xB0,
+
+#define PHY_DATA_INVERT     (0x1 << 3)
+#define PHY0_RST_MASK		(0x1 << 4)
+#define PHY_RST_MASK_ALL	(0xF << 4)
+
+	/* hisi extended registers for each SATA port */
+	PORT_FIFOTH		= 0x44,
+	PORT_PHYCTL1    = 0x48,
+	PORT_PHYCTL     = 0x74,
+
+#define PHY_MODE_1_5G   0
+#define PHY_MODE_3G     1
+#define PHY_MODE_6G     2
+};
diff --git a/drivers/phy/hibvt/phy-hisi-usb.c b/drivers/phy/hibvt/phy-hisi-usb.c
new file mode 100644
index 0000000..fa67598
--- /dev/null
+++ b/drivers/phy/hibvt/phy-hisi-usb.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2015 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/of_address.h>
+
+#include "phy-hisi-usb.h"
+
+static int hisi_usb_phy_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct phy *phy;
+	struct hisi_priv *priv;
+	struct device_node *np = pdev->dev.of_node;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->peri_ctrl = of_iomap(np, 0);
+	if (IS_ERR(priv->peri_ctrl))
+		priv->peri_ctrl = NULL;
+
+	priv->misc_ctrl = of_iomap(np, 1);
+	if (IS_ERR(priv->misc_ctrl))
+		priv->misc_ctrl = NULL;
+
+	priv->switch_base = of_iomap(np, 2);
+	if (IS_ERR(priv->switch_base))
+		priv->switch_base = NULL;
+
+	phy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);
+	if (!phy)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, phy);
+	phy_set_drvdata(phy, priv);
+	hisi_usb_phy_on(phy);
+
+	return 0;
+}
+
+static int hisi_usb_phy_remove(struct platform_device *pdev)
+{
+	struct phy *phy = dev_get_drvdata(&pdev->dev);
+
+	hisi_usb_phy_off(phy);
+	return 0;
+}
+
+static const struct of_device_id hisi_usb_phy_of_match[] = {
+	{.compatible = "hisilicon,hisi-usb-phy",},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, hisi_usb_phy_of_match);
+
+#ifdef CONFIG_PM_SLEEP
+static int hisi_usb_phy_suspend(struct device *dev)
+{
+	struct phy *phy = dev_get_drvdata(dev);
+
+	hisi_usb_phy_off(phy);
+	return 0;
+}
+
+static int hisi_usb_phy_resume(struct device *dev)
+{
+	struct phy *phy = dev_get_drvdata(dev);
+
+	hisi_usb_phy_on(phy);
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static SIMPLE_DEV_PM_OPS(hisi_usb2_pm_ops, hisi_usb_phy_suspend,
+		       hisi_usb_phy_resume);
+
+static struct platform_driver hisi_usb_phy_driver = {
+	.probe	= hisi_usb_phy_probe,
+	.remove = hisi_usb_phy_remove,
+	.driver = {
+		.name	= "hisi-usb-phy",
+		.pm	= &hisi_usb2_pm_ops,
+		.of_match_table	= hisi_usb_phy_of_match,
+	}
+};
+module_platform_driver(hisi_usb_phy_driver);
+
+MODULE_AUTHOR("Pengcheng Li <lpc.li@hisilicon.com>");
+MODULE_DESCRIPTION("HISILICON USB PHY driver");
+MODULE_ALIAS("platform:hisi-usb-phy");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/phy/hibvt/phy-hisi-usb.h b/drivers/phy/hibvt/phy-hisi-usb.h
new file mode 100644
index 0000000..28b9b08
--- /dev/null
+++ b/drivers/phy/hibvt/phy-hisi-usb.h
@@ -0,0 +1,8 @@
+extern void hisi_usb_phy_on(struct phy *phy);
+extern void hisi_usb_phy_off(struct phy *phy);
+struct hisi_priv {
+	void __iomem	*base;
+	void __iomem	*peri_ctrl;
+	void __iomem	*misc_ctrl;
+	void __iomem	*switch_base;
+};
